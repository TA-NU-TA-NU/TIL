# 1. コーディングを支える技術読書感想文やら

- [1. コーディングを支える技術読書感想文やら](#1-コーディングを支える技術読書感想文やら)
  - [1.1. 基本情報](#11-基本情報)
  - [1.2. 感想・総括](#12-感想総括)
  - [1.3. メモったことや腑に落ちたことだらだら書く](#13-メモったことや腑に落ちたことだらだら書く)

## 1.1. 基本情報

書名：『コーディングを支える技術　―　成り立ちから学ぶプログラミング作法』  
著者：西尾泰和 氏  

## 1.2. 感想・総括

設計者によって楽さの定義が違う。良しとしている点が違う。  
故にそれがニュアンスのことなった言語に分化する。  
又、その定義のお陰で設計思想や採用技術がことなる。  
そこに優劣などの一方的価値判断が挟まるからめんどくさくなる。そんなものはないのだ。  
そもそも、使う側からすれば、そうした特色の理解と目的から最適なものを選ぶ必要があるのみで、  
「～さえやれば安泰！」みたいな硬直的なものの考えかたは(今だとPythonとか?一昔まえのJava?)かなり偏った考え方である。  
これは昨今の「プログラミングスクールに行けば…」「エンジニアになれば…」も同じ図式だ…。  
これには流行り廃りだけでなくや使われる、求められる場面により最適さが異なるからだ。  
で、あるならば、言語を学ぶとはどういう姿勢であるべきか？  
それは言語の根底にある共通項や底に横たわる思想の様なものを会得するところにあるのだと思う。

## 1.3. メモったことや腑に落ちたことだらだら書く  

言語差異は方言のようなもの  
言語の底に横たわる共通(異なる)の思想や考え方を比較によってまなぶのがよい。  

----------

言語の差異はなにか?  
言語設計書が何を目指すかによってことなる。  
大抵の場合それぞれの理想の楽さがある。  
楽さの定義は言語設計者によってまちまち  
ひいてはそれが言語の得手不得手になる。  
  
これは金槌とドライバー位違うので比較するのはナンセンス  
その言語での適材適所をみきわめて、生産性を発揮できるエンジニアがもっとも評価される？  
  
----------

スタックマシン
マシン語にちかいかんじだが言語の演算の根幹のひとつ  
スタックしたもののうち上から二つの要素をオペランドをきっかけとして取り出してオペランドで定義した操作をする  
  
----------
  
構文木  
オペランドを頂点に木を作る  
言語による違いはこの構文木を作るさいや読み込む際の違い  
  
----------
  
記法  

- ポーランド記法
- 逆ポーランド記法  
- 中置記法  
etc..
  
----------
  
構文解析機(パーサ)  
ソ－スコードから構文木をつくる

こういう構文だと分かりやすそうというところから  
ルールがうまれる。制約が生まれる。  
特色や制限,特有の癖  

取っつきやすいように  
構文解析器を改良しようとしたり  
新しい機能をいれようとしたりするけど  
その皺寄せがどっかにでる。  

その結果がシェアとか書きやすさとか言語独特の癖とかになってあらわれるのかな。
  
----------
  
言語の違いはある意味、プログラミングのしやすさのために  
cpuとメモリのつかいやすさをどうデザインしてあげるかというもんだいなのかなと感じた  
大体の場合行き着く先が似かよってくる.  
それは、解決したい問題や課題、今なお結論のでない議論などになる。  
  
この時にどう暫定的な、答えをだすか、が言語の根底にある思想や仕様、方言などにはねる。  
  
----------
  
変数は、
メモリと名前空間と衝突の問題

どうやって閉じ込める？
リソースを汚させたくない。→スコープをおいてあげる  

----------
  
型とはなにか
01の羅列でしかないコンピューター上のメモリやレジスタの値に意味を見いだす行為。

凄い腹落ちしたのは  
型は仕様という考え方。  
  
型は01の羅列に枠組みと意味を与えてコンピューターに教える。  
  
拡張解釈していくと、  
構造体(structure)、公開非公開(アクセス修飾子など)、エラーの出力可能性定義(throw),class、interfaceもだだの01の羅列をそのように扱うという宣言。  

さらに、柔軟性を与えるために  
総称型、ジェネリックス、テンプレートができる。  
  
いずれも、定義時には型を決めず(曖昧にしておいて)実際に利用する際に具体的な型を渡してあげる。  
  
----------
  
並行処理プログラミング  
  
競合状態が起こるための要素  

- 二つの処理が変数を競合している  
- 少なくともひとつの処理が変数を書き換える  
- 一方の処理が一段落つく前にもう一方が割り込む可能性がある  
  
テレビのチャンネルやゲームの本体を兄弟で取り合う様子ににている  
  
共有できるリソースでおこる
例）ファイル、DB  
  
----------
  
・プロセス  
unixの一時期のプロセスの設計思想はプロセスごとにメモリを割り当てることでメモリの共有を防ぐスタイルであった  
  
しかしこれは容量をくうので、  
スレッドがうまれる  
  
----------
  
・アクターモデル  
Javaの前進smalltalkで採用された  
非同期処理とも  
相手のキューに処理内容をいれておいて、  
終わったら依頼主にしらせてねってする  
メッセージとかね  
  
----------

・書き換えないスタイル  
書き換えなければ問題は起きないので、  
const 定数 val immutable  
  
----------  

協調する
ロック セマンティクス  
更衣室の使用中のサインと同じで  
皆がルールを守れば快適につかえてよいかんじ…？  
  
デッドロックとかロックの順番とか  
それでも割り込む変態さんとかどうすんの問題  
  
→コピーして  
中途半端な状態じゃなくなってら反映  
反映したときに不整合があればやり直し  

DBなんかの更新の方法はこれ  
  
----------  

オブジェクト、クラスについて…どんな共通項があるだろうか

- 変数をまとめる
- 関数をまとめる
- 再利用可能にする
- プロトタイプを使ってまとめる
- 初期化
- 仕様を与える(型の概念の拡張)
  
----------  

クロージャーと閉じた変数と開いた変数  
  
参照しにはいくがスコープ内で定義されてない変数を**自由変数**という
自由変数を含んだ式を**開いた式**という  
値と変数(名)を結びつける行為を**束縛**という  
これ以上外のスコープに変数の定義を探しにいかなくて良い状態の式を**閉じた式**という  

クロージャーの概念は、自由変数をあるスコープで束縛してやることで閉じた式にすること
静的スコープ内に変数を閉じ込めることで状態の保持をする関数を作ろうとする試みがベース
  
----------  
  
結局、クラスってなんなの

言語の設計者によってクラスにもとめるものや、重視してきたことが違うから少しずれがある。  
これがクラス論争やOOP論争の根元かな。論争って無益なのかな

…本によると視点は３つ
1.まとまったものをつくる生成器
javascript,perlではここ。鯛焼きのかたとか複製とかのイメージで語られる時はこれを指す。

2.どういう操作が可能なのか、仕様の定義
c++、Java
型は仕様の表明、
Javaではさらに踏み込んでメッセージを受け取ったオブジェクトがどんな振る舞いをするのかの仕様
インターフェース、エラー、アクセス修飾子、メソッド

3.コードを再利用する単位
継承  
  
----------  
  
継承とは…  
  
- 一般化
- 特殊化
- 共通部分の抽出
- 差分実装(この場合は機能の拡張や修正なので、as a関係かといわれるとびみょい)

これらの自由度の高さがバグの原因  
gotoと同じような背景。  
  
----------  
  
継承問題の根本とは？  
２側面の目的？使われ方が相反している  
金型としての継承インスタンス作成  
必要十分であってほしい。これひとつで充足しておること。  
  
機能の再利用目的  
機能一つに絞って余計なものはあってほしくない。小さくあってほしい。  
  
どうやって解決する？  
多重継承の禁止  
委譲、di,インターフェース  
  
メソッドの解決順序を定めとく  
菱形継承が問題となるのでc3線形化で順序をきめとく  
  
ミックスイン
小さな先祖クラスから子供らは好きなものを混ぜ合わせて継承  
  
トレイト  
クラスより小さい。小さな機能ごとにメソッドレベルの再利用。  
(これが便利すぎて第3のgotoになってるらしい)  
